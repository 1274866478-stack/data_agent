# Data Agent V4 - 第14部分：错误处理策略

## 错误处理原则

### 1. 用户友好的错误信息
- 技术错误信息转换为用户可理解的消息
- 提供明确的错误原因和解决方案
- 避免暴露内部系统架构

### 2. 结构化错误响应
- 统一的错误响应格式
- 错误分类和编码
- 详细的错误日志记录

## 前端错误处理

### React 错误边界

```typescript
// components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react'
import { AlertTriangle } from 'lucide-react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  }

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo)
    // 发送错误到监控服务
    this.reportError(error, errorInfo)
  }

  private reportError = (error: Error, errorInfo: ErrorInfo) => {
    // 集成 Sentry 或其他错误监控服务
    if (window.Sentry) {
      window.Sentry.captureException(error, {
        contexts: {
          react: {
            componentStack: errorInfo.componentStack
          }
        }
      })
    }
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="flex items-center justify-center min-h-screen">
          <div className="text-center">
            <AlertTriangle className="h-12 w-12 text-red-500 mx-auto mb-4" />
            <h2 className="text-xl font-semibold mb-2">出现了一些问题</h2>
            <p className="text-gray-600 mb-4">请刷新页面重试，或联系技术支持</p>
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              刷新页面
            </button>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}
```

### API 错误处理

```typescript
// lib/api.ts
export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

export const handleApiError = (error: unknown): ApiError => {
  if (error instanceof ApiError) {
    return error
  }

  if (error instanceof Response) {
    return new ApiError(
      `API request failed: ${error.statusText}`,
      error.status,
      error.status === 401 ? 'UNAUTHORIZED' :
      error.status === 403 ? 'FORBIDDEN' :
      error.status === 404 ? 'NOT_FOUND' :
      error.status === 429 ? 'RATE_LIMIT' : 'UNKNOWN'
    )
  }

  if (error instanceof Error) {
    return new ApiError(error.message, 500, 'UNKNOWN')
  }

  return new ApiError('Unknown error occurred', 500, 'UNKNOWN')
}

// 使用示例
export const apiClient = {
  async query(question: string): Promise<QueryResponse> {
    try {
      const response = await fetch('/api/v1/query', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${getToken()}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ question })
      })

      if (!response.ok) {
        throw new ApiError(
          `Query failed: ${response.statusText}`,
          response.status
        )
      }

      return response.json()
    } catch (error) {
      throw handleApiError(error)
    }
  }
}
```

## 后端错误处理

### FastAPI 异常处理器

```python
# app/exceptions.py
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
import logging

logger = logging.getLogger(__name__)

class BaseCustomException(Exception):
    def __init__(self, message: str, code: str = None):
        self.message = message
        self.code = code
        super().__init__(self.message)

class TenantNotFoundException(BaseCustomException):
    def __init__(self, tenant_id: str):
        super().__init__(f"Tenant {tenant_id} not found", "TENANT_NOT_FOUND")

class DataSourceConnectionError(BaseCustomException):
    def __init__(self, message: str):
        super().__init__(f"Database connection error: {message}", "DB_CONNECTION_ERROR")

# app/main.py
from fastapi import FastAPI
from app.exceptions import BaseCustomException

app = FastAPI()

@app.exception_handler(BaseCustomException)
async def custom_exception_handler(request: Request, exc: BaseCustomException):
    logger.error(f"Custom exception: {exc.code} - {exc.message}")
    return JSONResponse(
        status_code=400,
        content={
            "error": {
                "code": exc.code or "UNKNOWN_ERROR",
                "message": exc.message,
                "type": "custom_exception"
            }
        }
    )

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    logger.error(f"Validation error: {exc.errors()}")
    return JSONResponse(
        status_code=422,
        content={
            "error": {
                "code": "VALIDATION_ERROR",
                "message": "Invalid request data",
                "details": exc.errors(),
                "type": "validation_error"
            }
        }
    )
```

### 业务逻辑错误处理

```python
# app/services/query_service.py
from app.exceptions import TenantNotFoundException, DataSourceConnectionError

class QueryService:
    async def execute_query(self, question: str, tenant_id: str):
        try:
            # 验证租户存在
            tenant = await self.get_tenant(tenant_id)
            if not tenant:
                raise TenantNotFoundException(tenant_id)

            # 获取数据源连接
            connection = await self.get_tenant_database_connection(tenant_id)
            if not connection:
                raise DataSourceConnectionError("No database connection configured")

            # 执行查询
            result = await self.agentic_core.process_query(question, tenant_id)
            return result

        except TenantNotFoundException:
            # 重新抛出业务异常
            raise
        except Exception as e:
            # 记录未处理的异常并包装
            logger.error(f"Unexpected error in query execution: {str(e)}")
            raise BaseCustomException("Query execution failed", "QUERY_EXECUTION_ERROR")
```

## 错误分类和处理策略

### 1. 认证错误 (401/403)
**前端处理**:
```typescript
const handleAuthError = (error: ApiError) => {
  if (error.status === 401 || error.status === 403) {
    // 清除本地认证状态
    clearAuthState()
    // 重定向到登录页面
    window.location.href = '/sign-in'
  }
}
```

**后端处理**:
```python
@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request: Request, exc: StarletteHTTPException):
    if exc.status_code in (401, 403):
        logger.warning(f"Auth error on {request.url}: {exc.detail}")

    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": {
                "code": "AUTH_ERROR" if exc.status_code == 401 else "PERMISSION_DENIED",
                "message": exc.detail,
                "type": "http_exception"
            }
        }
    )
```

### 2. 数据库连接错误
**重试策略**:
```python
import asyncio
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10)
)
async def connect_to_database(connection_string: str):
    try:
        return await asyncpg.connect(connection_string)
    except Exception as e:
        logger.error(f"Database connection attempt failed: {e}")
        raise DataSourceConnectionError(str(e))
```

### 3. 外部 API 错误 (Zhipu)
**限流和重试**:
```python
import aiohttp
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(2),
    wait=wait_exponential(multiplier=1, min=1, max=4),
    retry=retry_if_exception_type(aiohttp.ClientError)
)
async def call_zhipu_api(prompt: str):
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                "https://open.bigmodel.cn/api/paas/v4/chat/completions",
                headers={"Authorization": f"Bearer {settings.ZHIPUAI_API_KEY}"},
                json={"model": "glm-4", "messages": [{"role": "user", "content": prompt}]}
            ) as response:
                if response.status == 429:
                    raise BaseCustomException("Rate limit exceeded", "RATE_LIMIT")
                response.raise_for_status()
                return await response.json()
    except aiohttp.ClientError as e:
        logger.error(f"Zhipu API call failed: {e}")
        raise BaseCustomException("LLM service unavailable", "LLM_ERROR")
```

## 错误监控和日志

### 结构化日志记录

```python
# app/utils/logging.py
import json
import logging
from datetime import datetime

class StructuredLogger:
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)

    def log_error(self, error: Exception, context: dict = None):
        error_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": "ERROR",
            "error": {
                "type": error.__class__.__name__,
                "message": str(error),
                "traceback": traceback.format_exc()
            },
            "context": context or {}
        }
        self.logger.error(json.dumps(error_data))

# 使用示例
logger = StructuredLogger(__name__)

try:
    # 业务逻辑
    result = await some_operation()
except Exception as e:
    logger.log_error(e, {
        "tenant_id": tenant_id,
        "operation": "query_execution",
        "user_agent": request.headers.get("User-Agent")
    })
    raise
```

### 前端错误监控

```typescript
// utils/errorReporting.ts
interface ErrorContext {
  tenantId?: string
  userId?: string
  operation?: string
  userAgent?: string
  url?: string
}

export const reportError = (error: Error, context: ErrorContext = {}) => {
  // 发送到错误监控服务
  if (window.Sentry) {
    window.Sentry.captureException(error, {
      tags: {
        tenantId: context.tenantId,
        operation: context.operation
      },
      extra: context
    })
  }

  // 本地日志记录
  console.error('Application error:', {
    error: error.message,
    stack: error.stack,
    context
  })
}
```

---
**分片索引**: 14-错误处理策略.md | **总页数**: 14/17