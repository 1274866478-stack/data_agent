# Data Agent V4 - 第12部分：测试策略

## Backend Tests (Pytest)

### 1. 租户隔离测试 (V4 核心)

**目标**: 验证不同租户之间的数据完全隔离

**测试用例**:
```python
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

@pytest.mark.asyncio
async def test_tenant_isolation(client: TestClient, db: Session):
    # 创建两个租户
    tenant_a = "tenant-a-id"
    tenant_b = "tenant-b-id"

    # 为租户 A 添加数据
    client.post(
        "/data-sources/database",
        json={"name": "Tenant A DB", "connection_string": "postgresql://..."},
        headers={"Authorization": f"Bearer {get_jwt_token(tenant_a)}"}
    )

    # 为租户 B 添加数据
    client.post(
        "/data-sources/database",
        json={"name": "Tenant B DB", "connection_string": "postgresql://..."},
        headers={"Authorization": f"Bearer {get_jwt_token(tenant_b)}"}
    )

    # 验证租户 A 不能访问租户 B 的数据
    response_a = client.get(
        "/data-sources",
        headers={"Authorization": f"Bearer {get_jwt_token(tenant_a)}"}
    )

    # 断言只能看到自己的数据源
    data_sources = response_a.json()
    for ds in data_sources:
        assert ds["name"] == "Tenant A DB"
        assert "Tenant B DB" not in ds["name"]
```

### 2. 数据源连接测试 (V4 核心)

**目标**: 验证数据源连接的有效性检查

**测试用例**:
```python
@pytest.mark.asyncio
async def test_database_connection_validation(client: TestClient):
    # 测试无效连接字符串
    invalid_connection = "postgresql://invalid:connection@localhost:5432/db"
    response = client.post(
        "/data-sources/database",
        json={"name": "Invalid DB", "connection_string": invalid_connection},
        headers={"Authorization": f"Bearer {get_jwt_token()}"}
    )

    assert response.status_code == 400
    assert "connection string invalid" in response.json()["detail"].lower()

    # 测试有效连接字符串
    valid_connection = "postgresql://user:pass@localhost:5432/testdb"
    response = client.post(
        "/data-sources/database",
        json={"name": "Valid DB", "connection_string": valid_connection},
        headers={"Authorization": f"Bearer {get_jwt_token()}"}
    )

    assert response.status_code == 201
```

### 3. JWT 认证测试

**目标**: 验证认证机制的安全性

**测试用例**:
```python
@pytest.mark.asyncio
async def test_jwt_authentication(client: TestClient):
    # 测试无 JWT 的请求
    response = client.post("/query", json={"question": "test"})
    assert response.status_code == 401

    # 测试无效 JWT 的请求
    response = client.post(
        "/query",
        json={"question": "test"},
        headers={"Authorization": "Bearer invalid_token"}
    )
    assert response.status_code == 401

    # 测试有效 JWT 的请求
    response = client.post(
        "/query",
        json={"question": "test"},
        headers={"Authorization": f"Bearer {get_valid_jwt_token()}"}
    )
    assert response.status_code == 200
```

## Frontend Tests (Jest + Testing Library)

### 1. 组件测试

**认证组件测试**:
```typescript
import { render, screen, waitFor } from '@testing-library/react'
import { AuthProvider } from '../contexts/AuthContext'

test('redirects unauthenticated users to login', async () => {
  render(
    <AuthProvider>
      <ProtectedPage />
    </AuthProvider>
  )

  await waitFor(() => {
    expect(window.location.pathname).toBe('/sign-in')
  })
})

test('authenticated users can access protected content', async () => {
  const mockUser = { id: 'user-1', tenantId: 'tenant-1' }

  render(
    <AuthProvider initialUser={mockUser}>
      <ProtectedPage />
    </AuthProvider>
  )

  await waitFor(() => {
    expect(screen.getByText('Welcome to Dashboard')).toBeInTheDocument()
  })
})
```

### 2. API 集成测试

```typescript
import { renderHook, act } from '@testing-library/react-hooks'
import { useApiQuery } from '../hooks/useApi'

test('handles API errors gracefully', async () => {
  const { result } = renderHook(() => useApiQuery())

  await act(async () => {
    await result.current.query('test question')
  })

  expect(result.current.error).toBeTruthy()
  expect(result.current.loading).toBe(false)
})
```

## 集成测试

### 1. 端到端测试 (Playwright)

```typescript
import { test, expect } from '@playwright/test'

test('complete tenant onboarding flow', async ({ page }) => {
  // 1. 用户注册
  await page.goto('/sign-up')
  await page.fill('[data-testid=email]', 'test@example.com')
  await page.fill('[data-testid=password]', 'password123')
  await page.click('[data-testid=sign-up-button]')

  // 2. 添加数据源
  await page.goto('/data-sources')
  await page.click('[data-testid=add-database-button]')
  await page.fill('[data-testid=connection-string]', 'postgresql://localhost/test')
  await page.click('[data-testid=save-button]')

  # 3. 执行查询
  await page.goto('/')
  await page.fill('[data-testid=query-input]', 'Show me products')
  await page.click('[data-testid=submit-button]')

  // 4. 验证响应
  await expect(page.locator('[data-testid=answer]')).toBeVisible()
  await expect(page.locator('[data-testid=citations]')).toContainText('products')
})
```

### 2. 性能测试

**负载测试 (Locust)**:
```python
from locust import HttpUser, task, between

class ApiUser(HttpUser):
    wait_time = between(1, 3)

    def on_start(self):
        # 获取 JWT token
        response = self.client.post("/auth/token", json={
            "email": "test@example.com",
            "password": "password"
        })
        self.token = response.json()["access_token"]

    @task
    def query_data(self):
        headers = {"Authorization": f"Bearer {self.token}"}
        self.client.post("/query",
                        json={"question": "What are our top products?"},
                        headers=headers)
```

## 测试数据管理

### 1. 测试数据库

**设置**: 使用独立的测试数据库
**清理**: 每次测试后清理数据
**隔离**: 并行测试使用不同的租户 ID

### 2. Mock 服务

**外部 API Mock**:
```python
# Mock Zhipu API
@pytest.fixture
def mock_zhipu_api(monkeypatch):
    async def mock_chat_completion(*args, **kwargs):
        return {
            "choices": [{
                "message": {"content": "This is a test response"}
            }]
        }

    monkeypatch.setattr("zhipu.ChatCompletion.create", mock_chat_completion)
```

## 测试覆盖率目标

- **Backend**: 90% 代码覆盖率
- **Frontend**: 80% 代码覆盖率
- **E2E Tests**: 覆盖关键用户流程
- **Security Tests**: 100% 认证和授权路径

---
**分片索引**: 12-测试策略.md | **总页数**: 12/17