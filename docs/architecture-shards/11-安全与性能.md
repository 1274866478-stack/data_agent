# Data Agent V4 - 第11部分：安全与性能

## Security Requirements (安全要求)

### 1. 认证安全

**JWT 认证**:
- 使用托管认证提供商（Clerk/Auth0）的公钥验证每个请求
- JWT 包含租户 ID 和用户角色信息
- 令牌过期时间: 15 分钟 (访问令牌), 7 天 (刷新令牌)

**实施要点**:
```python
# 后端 JWT 验证
async def verify_jwt_token(token: str):
    try:
        payload = jwt.decode(token, CLERK_PUBLIC_KEY, algorithms=["RS256"])
        tenant_id = payload.get("tenant_id")
        user_id = payload.get("sub")
        return tenant_id, user_id
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")
```

### 2. 数据隔离

**租户隔离** (V4 核心):
- 所有数据库查询必须包含 `WHERE tenant_id = '...'` 子句
- ChromaDB 向量检索必须使用 `where={"tenant_id": tenant_id}` 过滤
- 文件存储路径必须包含租户前缀

**实施示例**:
```python
# SQL 查询示例
query = "SELECT * FROM products WHERE tenant_id = :tenant_id AND name ILIKE :search"
params = {"tenant_id": tenant_id, "search": f"%{search_term}%"}

# 向量检索示例
results = collection.query(
    query_embeddings=embedding,
    where={"tenant_id": tenant_id}
)
```

### 3. 凭证安全

**连接字符串加密**:
- 用户提供的数据库连接字符串必须加密存储
- 使用 AES-256-GCM 加密算法
- 加密密钥存储在环境变量中

```python
from cryptography.fernet import Fernet

def encrypt_connection_string(connection_string: str) -> str:
    key = settings.ENCRYPTION_KEY.encode()
    f = Fernet(key)
    return f.encrypt(connection_string.encode()).decode()

def decrypt_connection_string(encrypted: str) -> str:
    key = settings.ENCRYPTION_KEY.encode()
    f = Fernet(key)
    return f.decrypt(encrypted.encode()).decode()
```

## Performance Optimization (性能优化)

### 1. 数据库性能

**连接池管理**:
- 使用 asyncpg 连接池
- 配置合适的连接池大小 (20-50)
- 实现连接健康检查

**查询优化**:
- 在 tenant_id 和常用查询字段上建立索引
- 使用 EXPLAIN ANALYZE 优化慢查询
- 实现查询结果缓存

**索引策略**:
```sql
-- 租户表索引
CREATE INDEX idx_tenants_email ON tenants(email);
CREATE INDEX idx_tenants_created_at ON tenants(created_at);

-- 数据源连接索引
CREATE INDEX idx_data_sources_tenant_id ON data_source_connections(tenant_id);
CREATE INDEX idx_data_sources_db_type ON data_source_connections(db_type);

-- 文档索引
CREATE INDEX idx_documents_tenant_id ON knowledge_documents(tenant_id);
CREATE INDEX idx_documents_status ON knowledge_documents(status);
```

### 2. API 性能

**响应缓存**:
- 使用 Redis 缓存常见查询结果
- 实现智能缓存失效策略
- 设置合理的缓存过期时间

**并发处理**:
- 使用 FastAPI 的异步特性
- 实现请求限流 (Rate Limiting)
- 配置超时机制

**批处理优化**:
```python
# 批量文档索引
async def batch_index_documents(documents: List[Document], tenant_id: str):
    batch_size = 10
    for i in range(0, len(documents), batch_size):
        batch = documents[i:i+batch_size]
        await asyncio.gather(*[
            index_single_document(doc, tenant_id)
            for doc in batch
        ])
```

### 3. 前端性能

**代码分割**:
- 使用 Next.js 动态导入
- 路由级别的代码分割
- 组件懒加载

**资源优化**:
- 图片自动优化 (WebP 格式)
- 字体子集化
- CSS 和 JavaScript 压缩

**缓存策略**:
- 静态资源长期缓存
- API 响应适当缓存
- Service Worker 离线支持

## 监控指标

### 性能指标
- **API 响应时间**: P95 < 2 秒
- **数据库查询时间**: P95 < 500ms
- **前端首屏加载**: < 3 秒
- **向量检索时间**: < 1 秒

### 安全指标
- **认证失败率**: < 0.1%
- **数据泄露尝试**: 0 (必须阻止)
- **加密覆盖率**: 100%
- **租户数据隔离验证**: 每次部署后测试

---
**分片索引**: 11-安全与性能.md | **总页数**: 11/17