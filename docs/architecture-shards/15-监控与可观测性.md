# Data Agent V4 - 第15部分：监控与可观测性

## MVP 监控策略

对于本地 MVP，监控策略简化为：Docker Compose 日志（后端）和浏览器 F12 工具（前端）。

## 本地开发监控

### 1. Docker Compose 日志监控

**查看所有服务日志**:
```bash
# 实时查看所有服务日志
docker compose logs -f

# 查看特定服务日志
docker compose logs -f backend
docker compose logs -f frontend
docker compose logs -f db

# 查看最近的日志（最后 100 行）
docker compose logs --tail=100 backend
```

**日志级别配置**:
```yaml
# docker-compose.yml
services:
  backend:
    environment:
      - LOG_LEVEL=INFO  # DEBUG, INFO, WARNING, ERROR
      - LOG_FORMAT=json  # json 或 text
    volumes:
      - ./logs:/app/logs  # 挂载日志目录
```

### 2. 前端开发调试

**浏览器开发者工具**:
- **Console**: JavaScript 错误和 API 调用
- **Network**: HTTP 请求/响应详情
- **Performance**: 页面加载性能分析
- **Application**: Local Storage 和状态管理

**React DevTools**:
```typescript
// 安装 React Developer Tools 浏览器扩展
// 查看组件状态、props 和性能

// 在组件中添加调试信息
import { useEffect } from 'react'

export function QueryComponent({ query, tenantId }) {
  useEffect(() => {
    console.debug('QueryComponent render:', { query, tenantId })
  })

  // 组件逻辑
}
```

## 生产监控准备

虽然 MVP 使用简化的监控，但架构设计为生产环境的完整监控做准备。

### 1. 应用性能监控 (APM)

**后端监控指标**:
```python
# app/monitoring.py
import time
import functools
from prometheus_client import Counter, Histogram, generate_latest

# 定义监控指标
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')
QUERY_COUNT = Counter('queries_total', 'Total queries processed', ['tenant_id', 'status'])
LLM_TOKEN_USAGE = Counter('llm_tokens_used_total', 'Total LLM tokens used', ['tenant_id'])

def monitor_request(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            REQUEST_COUNT.labels(method='POST', endpoint='/query', status='success').inc()
            return result
        except Exception as e:
            REQUEST_COUNT.labels(method='POST', endpoint='/query', status='error').inc()
            raise
        finally:
            REQUEST_DURATION.observe(time.time() - start_time)
    return wrapper

# FastAPI 集成
@app.get("/metrics")
async def metrics():
    return Response(generate_latest(), media_type="text/plain")
```

**前端监控**:
```typescript
// lib/monitoring.ts
interface PageView {
  url: string
  timestamp: number
  tenantId?: string
  userAgent: string
}

interface PerformanceMetric {
  name: string
  value: number
  timestamp: number
}

class MonitoringService {
  private pageViews: PageView[] = []
  private performanceMetrics: PerformanceMetric[] = []

  trackPageView(url: string, tenantId?: string) {
    const pageView: PageView = {
      url,
      timestamp: Date.now(),
      tenantId,
      userAgent: navigator.userAgent
    }

    this.pageViews.push(pageView)
    console.debug('Page view tracked:', pageView)

    // 发送到监控服务（生产环境）
    // this.sendToMonitoring(pageView)
  }

  trackPerformance(name: string, value: number) {
    const metric: PerformanceMetric = {
      name,
      value,
      timestamp: Date.now()
    }

    this.performanceMetrics.push(metric)
    console.debug('Performance metric tracked:', metric)
  }

  trackApiCall(endpoint: string, duration: number, success: boolean) {
    this.trackPerformance(`api_${endpoint}`, duration)
    console.debug('API call tracked:', { endpoint, duration, success })
  }
}

export const monitoring = new MonitoringService()
```

### 2. 健康检查端点

**后端健康检查**:
```python
# app/health.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from app.database import get_db
import asyncpg
import redis

router = APIRouter()

@router.get("/health")
async def health_check(db: Session = Depends(get_db)):
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {}
    }

    # 检查数据库连接
    try:
        await db.execute("SELECT 1")
        health_status["services"]["database"] = "healthy"
    except Exception as e:
        health_status["services"]["database"] = f"unhealthy: {str(e)}"
        health_status["status"] = "degraded"

    # 检查向量数据库
    try:
        # ChromaDB 健康检查
        collection = client.get_collection("health_check")
        health_status["services"]["vector_db"] = "healthy"
    except Exception as e:
        health_status["services"]["vector_db"] = f"unhealthy: {str(e)}"
        health_status["status"] = "degraded"

    # 检查对象存储
    try:
        # MinIO 健康检查
        minio_client.list_buckets()
        health_status["services"]["object_storage"] = "healthy"
    except Exception as e:
        health_status["services"]["object_storage"] = f"unhealthy: {str(e)}"
        health_status["status"] = "degraded"

    status_code = 200 if health_status["status"] == "healthy" else 503
    return JSONResponse(content=health_status, status_code=status_code)
```

### 3. 业务指标监控

**关键业务指标**:
```python
# app/analytics.py
class BusinessMetrics:
    def __init__(self):
        self.tenant_metrics = {}
        self.query_metrics = {}

    async def track_query(self, tenant_id: str, query: str, response_time: float, success: bool):
        # 按租户跟踪查询
        if tenant_id not in self.tenant_metrics:
            self.tenant_metrics[tenant_id] = {
                "query_count": 0,
                "success_count": 0,
                "avg_response_time": 0,
                "last_query_time": None
            }

        metrics = self.tenant_metrics[tenant_id]
        metrics["query_count"] += 1
        metrics["last_query_time"] = datetime.utcnow().isoformat()

        if success:
            metrics["success_count"] += 1

        # 更新平均响应时间
        metrics["avg_response_time"] = (
            (metrics["avg_response_time"] * (metrics["query_count"] - 1) + response_time) /
            metrics["query_count"]
        )

    async def track_data_source_operation(self, tenant_id: str, operation: str, success: bool):
        # 跟踪数据源操作（添加、删除、查询等）
        pass

    async def get_tenant_analytics(self, tenant_id: str):
        return self.tenant_metrics.get(tenant_id, {})

# 集成到查询服务
class QueryService:
    def __init__(self):
        self.metrics = BusinessMetrics()

    async def execute_query(self, question: str, tenant_id: str):
        start_time = time.time()
        success = False

        try:
            result = await self.process_query(question, tenant_id)
            success = True
            return result
        finally:
            response_time = time.time() - start_time
            await self.metrics.track_query(tenant_id, question, response_time, success)
```

### 4. 日志聚合和分析

**结构化日志格式**:
```python
# app/logging_config.py
import json
import logging
from datetime import datetime

class StructuredFormatter(logging.Formatter):
    def format(self, record):
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }

        # 添加租户上下文（如果可用）
        if hasattr(record, 'tenant_id'):
            log_entry["tenant_id"] = record.tenant_id

        # 添加请求 ID（如果可用）
        if hasattr(record, 'request_id'):
            log_entry["request_id"] = record.request_id

        return json.dumps(log_entry)

# 配置日志
def setup_logging():
    formatter = StructuredFormatter()

    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)

    # 文件处理器
    file_handler = logging.FileHandler('logs/app.log')
    file_handler.setFormatter(formatter)

    # 根日志器配置
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)
```

## 本地调试技巧

### 1. 查询性能分析

```python
# 添加查询分析装饰器
def analyze_query_performance(func):
    @functools.wraps(func)
    async def wrapper(question: str, tenant_id: str):
        start_time = time.time()

        # 记录查询开始
        logger.info("Query started", extra={
            "tenant_id": tenant_id,
            "question": question,
            "operation": "query_start"
        })

        try:
            result = await func(question, tenant_id)

            # 记录查询成功
            duration = time.time() - start_time
            logger.info("Query completed successfully", extra={
                "tenant_id": tenant_id,
                "duration": duration,
                "operation": "query_success"
            })

            return result

        except Exception as e:
            # 记录查询失败
            duration = time.time() - start_time
            logger.error("Query failed", extra={
                "tenant_id": tenant_id,
                "duration": duration,
                "error": str(e),
                "operation": "query_error"
            })
            raise

    return wrapper
```

### 2. 前端性能分析

```typescript
// 性能监控钩子
export function usePerformanceMonitor(operationName: string) {
  useEffect(() => {
    const startTime = performance.now()

    return () => {
      const endTime = performance.now()
      const duration = endTime - startTime

      monitoring.trackPerformance(`${operationName}_render`, duration)

      if (duration > 1000) {
        console.warn(`Slow render detected for ${operationName}: ${duration}ms`)
      }
    }
  }, [operationName])
}

// 使用示例
function QueryResults({ results }) {
  usePerformanceMonitor('QueryResults')

  return (
    <div>
      {/* 渲染查询结果 */}
    </div>
  )
}
```

## 监控仪表板配置

### Grafana 仪表板模板

```json
{
  "dashboard": {
    "title": "Data Agent V4 Monitoring",
    "panels": [
      {
        "title": "Query Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(queries_total[5m])",
            "legendFormat": "Queries/sec"
          }
        ]
      },
      {
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, http_request_duration_seconds)",
            "legendFormat": "95th percentile"
          }
        ]
      },
      {
        "title": "Tenant Activity",
        "type": "table",
        "targets": [
          {
            "expr": "queries_total by (tenant_id)",
            "format": "table"
          }
        ]
      }
    ]
  }
}
```

---
**分片索引**: 15-监控与可观测性.md | **总页数**: 15/17