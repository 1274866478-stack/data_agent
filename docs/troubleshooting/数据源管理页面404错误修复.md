# 数据源管理页面404错误修复报告

**日期**: 2025-11-20  
**问题**: 前端数据源管理页面显示 HTTP 404 错误和 SQL 列不存在错误  
**状态**: ✅ 已修复

---

## 问题描述

### 前端错误
- **HTTP error status: 404** - 获取数据源列表失败
- **SQL错误**: `column data_source_connections.db_type does not exist`
- 提示: `Perhaps you meant to reference the column "data_source_connections.type"`

### 用户影响
- 无法查看数据源列表
- 无法添加新的数据源连接
- 数据源管理功能完全不可用

---

## 根本原因分析

### 数据库表结构与代码模型不匹配

**数据库表结构** (来自 `backend/scripts/init-db.sql`):
```sql
CREATE TABLE data_source_connections (
    id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    name VARCHAR(255) NOT NULL,
    type connection_type NOT NULL,          -- ❌ 字段名: type
    status connection_status DEFAULT 'active',
    config JSONB NOT NULL DEFAULT '{}',     -- ❌ 字段名: config
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE,
    last_tested TIMESTAMP WITH TIME ZONE,
    test_result JSONB
);
```

**代码模型** (来自 `backend/src/app/data/models.py`):
```python
class DataSourceConnection(Base):
    __tablename__ = "data_source_connections"
    
    id = Column(String(255), primary_key=True)
    tenant_id = Column(String(255), nullable=False)
    name = Column(String(255), nullable=False)
    db_type = Column(String(50), nullable=False)           # ✅ 字段名: db_type
    _connection_string = Column(Text, nullable=False)      # ✅ 加密存储
    status = Column(Enum(DataSourceConnectionStatus))
    host = Column(String(255))                             # ✅ 详细连接信息
    port = Column(Integer)
    database_name = Column(String(100))
    created_at = Column(DateTime(timezone=True))
    updated_at = Column(DateTime(timezone=True))
```

### 关键差异
1. **字段名不匹配**: `type` vs `db_type`
2. **缺少加密字段**: 数据库没有 `_connection_string` 字段
3. **缺少连接详情**: 数据库没有 `host`, `port`, `database_name` 字段
4. **ID类型不同**: UUID vs VARCHAR(255)

---

## 解决方案

### 方案选择
选择**更新数据库表结构**以匹配代码模型，因为：
- ✅ 代码模型更完善，支持加密存储
- ✅ 代码模型提供详细的连接信息
- ✅ 符合Story 2.3的安全要求
- ✅ 前端已经基于此模型开发

### 实施步骤

#### 1. 创建迁移脚本
文件: `backend/scripts/migrate-data-source-connections.sql`

```sql
-- 备份现有数据
CREATE TABLE IF NOT EXISTS data_source_connections_backup AS 
SELECT * FROM data_source_connections;

-- 删除旧表
DROP TABLE IF EXISTS data_source_connections CASCADE;

-- 创建新表结构
CREATE TABLE data_source_connections (
    id VARCHAR(255) PRIMARY KEY,
    tenant_id VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    db_type VARCHAR(50) NOT NULL DEFAULT 'postgresql',
    _connection_string TEXT NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'testing',
    last_tested_at TIMESTAMP WITH TIME ZONE,
    test_result JSONB,
    host VARCHAR(255),
    port INTEGER,
    database_name VARCHAR(100),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- 创建索引
CREATE INDEX idx_data_source_connections_tenant_id ON data_source_connections(tenant_id);
CREATE INDEX idx_data_source_connections_status ON data_source_connections(status);
CREATE INDEX idx_data_source_connections_db_type ON data_source_connections(db_type);

-- 创建更新触发器
CREATE OR REPLACE FUNCTION update_data_source_connections_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_data_source_connections_updated_at
    BEFORE UPDATE ON data_source_connections
    FOR EACH ROW
    EXECUTE FUNCTION update_data_source_connections_updated_at();
```

#### 2. 执行迁移
```bash
# 在Windows PowerShell中执行
Get-Content backend/scripts/migrate-data-source-connections.sql | docker exec -i dataagent-postgres psql -U postgres -d dataagent
```

#### 3. 验证修复
```bash
# 检查表结构
docker exec -i dataagent-postgres psql -U postgres -d dataagent -c "\d data_source_connections"

# 测试API
curl http://localhost:8004/api/v1/data-sources?tenant_id=test-tenant
```

---

## 验证结果

### ✅ 数据库表结构
```
                                 Table "public.data_source_connections"
       Column       |           Type           | Nullable |             Default
--------------------+--------------------------+----------+---------------------------------
 id                 | character varying(255)   | not null | 
 tenant_id          | character varying(255)   | not null | 
 name               | character varying(255)   | not null | 
 db_type            | character varying(50)    | not null | 'postgresql'::character varying
 _connection_string | text                     | not null | 
 status             | character varying(50)    | not null | 'testing'::character varying
 last_tested_at     | timestamp with time zone |          | 
 test_result        | jsonb                    |          | 
 host               | character varying(255)   |          | 
 port               | integer                  |          | 
 database_name      | character varying(100)   |          | 
 created_at         | timestamp with time zone | not null | CURRENT_TIMESTAMP
 updated_at         | timestamp with time zone | not null | CURRENT_TIMESTAMP
```

### ✅ API响应
```bash
$ curl http://localhost:8004/api/v1/data-sources?tenant_id=test-tenant
[]  # 200 OK - 空数组（正常，因为还没有数据）
```

### ✅ 前端页面
- 不再显示404错误
- 不再显示SQL错误
- 可以正常显示"还没有任何数据源"的空状态
- "添加数据源"按钮可用

---

## 后续建议

### 1. 更新初始化脚本
修改 `backend/scripts/init-db.sql` 以匹配新的表结构，避免未来重新初始化时出现同样问题。

### 2. 添加数据库迁移工具
考虑使用 Alembic 进行数据库版本管理：
```bash
cd backend
alembic init alembic
alembic revision --autogenerate -m "Update data_source_connections schema"
alembic upgrade head
```

### 3. 文档同步
更新以下文档以反映新的表结构：
- `docs/architecture-shards/04-数据模型.md`
- `docs/stories/Story-2.3-数据源连接管理.md`
- `backend/CLAUDE.md`

### 4. 测试覆盖
添加集成测试以验证：
- 数据源创建流程
- 连接字符串加密/解密
- 租户隔离
- API端点完整性

---

## 经验教训

1. **保持一致性**: 数据库schema和代码模型必须保持同步
2. **版本控制**: 使用迁移工具管理数据库变更
3. **文档更新**: 架构变更时同步更新文档
4. **测试先行**: 集成测试可以早期发现此类问题

---

## 相关文件

- 迁移脚本: `backend/scripts/migrate-data-source-connections.sql`
- 数据模型: `backend/src/app/data/models.py`
- API端点: `backend/src/app/api/v1/endpoints/data_sources.py`
- 前端Store: `frontend/src/store/dataSourceStore.ts`
- 前端页面: `frontend/src/app/(app)/data-sources/page.tsx`

